{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Getting Started | Data Prep | Data Exploration | Preprocessing | **Model Tuning** | Final Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "sys.path.insert(0, '../modules')\n",
    "\n",
    "# now read in the new function\n",
    "from helpers import get_data\n",
    "from preprocessor import Preprocessor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "# more imports\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "import sklearn\n",
    "from sklearn.metrics import make_scorer, roc_auc_score,classification_report, recall_score, confusion_matrix, precision_recall_curve, f1_score\n",
    "from sklearn.utils import resample\n",
    "from imblearn.over_sampling  import SMOTE, ADASYN\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.pipeline import make_pipeline\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.model_selection import cross_val_score, StratifiedKFold, train_test_split, GridSearchCV\n",
    "\n",
    "from sklearn.ensemble import GradientBoostingClassifier, RandomForestClassifier\n",
    "\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Read Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "X_train, y_train = get_data('train')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "X_test, y_test = get_data('test')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Use preprocessor on training data\n",
    "p = Preprocessor(cols_to_filter=['Competitor Type'])\n",
    "X_train = p.fit_transform(X_train)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "X_test = p.transform(X_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Transform y where 1 = Won and 0=Loss\n",
    "y_train = pd.get_dummies(y_train, drop_first=True)\n",
    "y_test = pd.get_dummies(y_test, drop_first=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "toc-hr-collapsed": true
   },
   "source": [
    "## Class Imbalance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0    0.775051\n",
       "1    0.224949\n",
       "Name: Won, dtype: float64"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Check percent of opportunity that were won (1) versus lost (0)\n",
    "y_train['Won'].value_counts(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Text(0, 0.5, 'Count')"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 864x576 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.figure(figsize=(12,8))\n",
    "deal_outcomes = y_train['Won'].value_counts()\n",
    "sns.barplot(y=deal_outcomes.values, x=deal_outcomes.index, alpha=0.6)\n",
    "plt.title('Distribution of Opportunity Result')\n",
    "plt.xlabel('Opportunity Result', fontsize=16)\n",
    "plt.ylabel('Count', fontsize=16)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/Jaime/miniconda3/envs/classification/lib/python3.7/site-packages/sklearn/utils/validation.py:724: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel().\n",
      "  y = column_or_1d(y, warn=True)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Original shape: (54519, 39) (54519, 1)\n",
      "Upsampled shape: (84510, 39) (84510, 1)\n",
      "SMOTE sample shape: (84510, 39) (84510,)\n"
     ]
    },
    {
     "ename": "NameError",
     "evalue": "name 'x_train_ad' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-10-2c374dac80f9>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     27\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Upsampled shape:\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX_train_u\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_train_u\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     28\u001b[0m \u001b[0mprint\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m\"SMOTE sample shape:\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx_train_sm\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_train_sm\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 29\u001b[0;31m \u001b[0mprint\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m\"ADASYN sample shape:\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx_train_ad\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_train_ad\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     30\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Downsampled shape:\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX_train_d\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_train_d\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'x_train_ad' is not defined"
     ]
    }
   ],
   "source": [
    "# Upsample minority class\n",
    "X_train_u, y_train_u = resample(X_train[y_train['Won'] == 1],\n",
    "                                y_train[y_train['Won'] == 1],\n",
    "                                replace=True,\n",
    "                                n_samples=X_train[y_train['Won'] == 0].shape[0],\n",
    "                                                  random_state=1)\n",
    "\n",
    "X_train_u = np.concatenate((X_train[y_train['Won'] == 0], X_train_u))\n",
    "y_train_u = np.concatenate((y_train[y_train['Won'] == 0], y_train_u))\n",
    "\n",
    "\n",
    "# Upsample using SMOTE\n",
    "sm = SMOTE(random_state=12, ratio = 1.0)\n",
    "x_train_sm, y_train_sm = sm.fit_sample(X_train, y_train)\n",
    "\n",
    "# Downsample majority class\n",
    "X_train_d, y_train_d = resample(X_train[y_train['Won'] == 0],\n",
    "                                y_train[y_train['Won'] == 0],\n",
    "                                replace=True,\n",
    "                                n_samples=X_train[y_train['Won'] == 1].shape[0],\n",
    "                                random_state=1)\n",
    "X_train_d = np.concatenate((X_train[y_train['Won'] == 1], X_train_d))\n",
    "y_train_d = np.concatenate((y_train[y_train['Won'] == 1], y_train_d))\n",
    "\n",
    "\n",
    "print(\"Original shape:\", X_train.shape, y_train.shape)\n",
    "print(\"Upsampled shape:\", X_train_u.shape, y_train_u.shape)\n",
    "print (\"SMOTE sample shape:\", x_train_sm.shape, y_train_sm.shape)\n",
    "print (\"ADASYN sample shape:\", x_train_ad.shape, y_train_ad.shape)\n",
    "print(\"Downsampled shape:\", X_train_d.shape, y_train_d.shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Test Methods with Logistic Regression (Using Cross Validation)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The best Recall Score for Original data:\n",
      "0.08291887484712597\n",
      "The best Recall Score for Upsampled data:\n",
      "0.6966749497100934\n",
      "The best Recall Score for SMOTE data:\n",
      "0.7782510945450243\n",
      "The best Recall Score for Downsampled data:\n",
      "0.6060850348709075\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "0.727176962789513"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Create Training Sets\n",
    "\n",
    "methods_train_data = {\"Original\": (X_train, y_train['Won']),\n",
    "                \"Upsampled\": (X_train_u, y_train_u[:,0]),\n",
    "                \"SMOTE\":(x_train_sm, y_train_sm),\n",
    "                \"Downsampled\": (X_train_d, y_train_d[:,0])}\n",
    "\n",
    "# 5-Fold cross validation using Logistic Regression\n",
    "for method in methods_train_data.keys():\n",
    "    lr_results = cross_val_score(LogisticRegression(solver='lbfgs'), methods_train_data[method][0], methods_train_data[method][1], cv=5, scoring='recall')\n",
    "    print(f\"The best Recall Score for {method} data:\")\n",
    "    print (lr_results.mean())\n",
    " \n",
    "cross_val_score(LogisticRegression(solver='lbfgs',class_weight='balanced'), X_train, y_train['Won'], cv=5, scoring='recall').mean()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "toc-hr-collapsed": true
   },
   "source": [
    "# Model Selection"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Logistic Regression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\n",
      " ---Logistic Regression Model---\n",
      "Logistic Regression AUC = 0.74\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "           0       0.93      0.66      0.77     18081\n",
      "           1       0.42      0.82      0.55      5327\n",
      "\n",
      "    accuracy                           0.70     23408\n",
      "   macro avg       0.67      0.74      0.66     23408\n",
      "weighted avg       0.81      0.70      0.72     23408\n",
      "\n"
     ]
    }
   ],
   "source": [
    "lr = LogisticRegression(solver='lbfgs')\n",
    "\n",
    "#Fit model\n",
    "# Fit the model to the Upsampling data\n",
    "lr = lr.fit(x_train_sm, y_train_sm)\n",
    "\n",
    "print (\"\\n\\n ---Logistic Regression Model---\")\n",
    "lr_auc = roc_auc_score(y_test['Won'], lr.predict(X_test))\n",
    "\n",
    "print (\"Logistic Regression AUC = %2.2f\" % lr_auc)\n",
    "\n",
    "lr2 = lr.fit(x_train_sm, y_train_sm)\n",
    "print(classification_report(y_test['Won'], lr.predict(X_test)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Random Forest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/Jaime/miniconda3/envs/classification/lib/python3.7/site-packages/sklearn/ensemble/forest.py:245: FutureWarning: The default value of n_estimators will change from 10 in version 0.20 to 100 in 0.22.\n",
      "  \"10 in version 0.20 to 100 in 0.22.\", FutureWarning)\n",
      "/Users/Jaime/miniconda3/envs/classification/lib/python3.7/site-packages/sklearn/ensemble/forest.py:245: FutureWarning: The default value of n_estimators will change from 10 in version 0.20 to 100 in 0.22.\n",
      "  \"10 in version 0.20 to 100 in 0.22.\", FutureWarning)\n",
      "/Users/Jaime/miniconda3/envs/classification/lib/python3.7/site-packages/sklearn/ensemble/forest.py:245: FutureWarning: The default value of n_estimators will change from 10 in version 0.20 to 100 in 0.22.\n",
      "  \"10 in version 0.20 to 100 in 0.22.\", FutureWarning)\n",
      "/Users/Jaime/miniconda3/envs/classification/lib/python3.7/site-packages/sklearn/ensemble/forest.py:245: FutureWarning: The default value of n_estimators will change from 10 in version 0.20 to 100 in 0.22.\n",
      "  \"10 in version 0.20 to 100 in 0.22.\", FutureWarning)\n",
      "/Users/Jaime/miniconda3/envs/classification/lib/python3.7/site-packages/sklearn/ensemble/forest.py:245: FutureWarning: The default value of n_estimators will change from 10 in version 0.20 to 100 in 0.22.\n",
      "  \"10 in version 0.20 to 100 in 0.22.\", FutureWarning)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "0.8485386344811265"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Random Forest Model\n",
    "rf = RandomForestClassifier()\n",
    "\n",
    "rf_result = cross_val_score(rf, x_train_sm, y_train_sm, cv=5, scoring='recall')\n",
    "\n",
    "rf_result.mean()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Gradient Boosting Classifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "GradientBoostingClassifier(criterion='friedman_mse', init=None,\n",
       "                           learning_rate=0.1, loss='deviance', max_depth=3,\n",
       "                           max_features=None, max_leaf_nodes=None,\n",
       "                           min_impurity_decrease=0.0, min_impurity_split=None,\n",
       "                           min_samples_leaf=1, min_samples_split=2,\n",
       "                           min_weight_fraction_leaf=0.0, n_estimators=100,\n",
       "                           n_iter_no_change=None, presort='auto',\n",
       "                           random_state=None, subsample=1.0, tol=0.0001,\n",
       "                           validation_fraction=0.1, verbose=0,\n",
       "                           warm_start=False)"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "gbc = GradientBoostingClassifier()  \n",
    "\n",
    "gbc = gbc.fit(x_train_sm,y_train_sm)\n",
    "\n",
    "gbc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.8497929239143296"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Cross Validation for GBC\n",
    "\n",
    "gbc_result = cross_val_score(gbc, x_train_sm, y_train_sm, cv=5, scoring='recall')\n",
    "gbc_result.mean()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Model Tuning"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create training and validation dataset\n",
    "x_train, x_valid, y_train, y_valid = train_test_split(x_train_sm, y_train_sm, test_size = 0.3, random_state=0, shuffle=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Testing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 120,
   "metadata": {},
   "outputs": [],
   "source": [
    "n_estimators = np.arange(400, 1000, 50)\n",
    "max_depth = [2,4,6]\n",
    "\n",
    "param_grid = {'n_estimators': n_estimators,\n",
    "              'max_depth': max_depth,}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 121,
   "metadata": {},
   "outputs": [],
   "source": [
    "rfc = RandomForestClassifier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 122,
   "metadata": {},
   "outputs": [],
   "source": [
    "gs = GridSearchCV(rfc, \n",
    "                  param_grid, \n",
    "                  cv=3,\n",
    "                  n_jobs=-1,\n",
    "                  scoring=make_scorer(recall_score))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "GridSearchCV(cv=3, error_score='raise-deprecating',\n",
       "             estimator=RandomForestClassifier(bootstrap=True, class_weight=None,\n",
       "                                              criterion='gini', max_depth=None,\n",
       "                                              max_features='auto',\n",
       "                                              max_leaf_nodes=None,\n",
       "                                              min_impurity_decrease=0.0,\n",
       "                                              min_impurity_split=None,\n",
       "                                              min_samples_leaf=1,\n",
       "                                              min_samples_split=2,\n",
       "                                              min_weight_fraction_leaf=0.0,\n",
       "                                              n_estimators='warn', n_jobs=None,\n",
       "                                              oob_score=False,\n",
       "                                              random_state=None, verbose=0,\n",
       "                                              warm_start=False),\n",
       "             iid='warn', n_jobs=-1,\n",
       "             param_grid={'max_depth': [2, 4, 6],\n",
       "                         'n_estimators': array([400, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950])},\n",
       "             pre_dispatch='2*n_jobs', refit=True, return_train_score=False,\n",
       "             scoring=make_scorer(recall_score), verbose=0)"
      ]
     },
     "execution_count": 123,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "gs.fit(x_train_sm,y_train_sm)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 113,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Best score for data1: 0.8429061649508934\n",
      "Best Parameters: {'max_depth': 4, 'n_estimators': 500}\n"
     ]
    }
   ],
   "source": [
    "# View best recall score and parameters\n",
    "print('Best score for data1:', gs.best_score_) \n",
    "print('Best Parameters:',gs.best_params_)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "metadata": {},
   "outputs": [],
   "source": [
    "mean_score = gs.cv_results_['mean_test_score']\n",
    "params = gs.cv_results_['params']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 119,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[{'max_depth': 2, 'n_estimators': 200},\n",
       " {'max_depth': 2, 'n_estimators': 500},\n",
       " {'max_depth': 4, 'n_estimators': 200},\n",
       " {'max_depth': 4, 'n_estimators': 500},\n",
       " {'max_depth': 6, 'n_estimators': 200},\n",
       " {'max_depth': 6, 'n_estimators': 500}]"
      ]
     },
     "execution_count": 119,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "params"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x123482e80>]"
      ]
     },
     "execution_count": 118,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(zip(mean_score)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [],
   "source": [
    "def select_params(X, y, max_estimators=1000, max_depth = 3, learning_rate=0.01):\n",
    "    \n",
    "\n",
    "    # Create validation set\n",
    "    #X_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.33, random_state=0, shuffle=True)\n",
    "    \n",
    "\n",
    "    gbc = GradientBoostingClassifier(n_estimators = max_estimators,\n",
    "                                     learning_rate=learning_rate, \n",
    "                                     max_depth=max_depth, \n",
    "                                     loss='deviance',\n",
    "                                     subsample=0.5)\n",
    "    \n",
    "    kfold = StratifiedKFold(n_splits=5, shuffle=True, random_state=7)\n",
    "    #n_estimators = [max_estimators for d in depth]\n",
    "    \n",
    "    param_grid = dict(max_depth=depth)\n",
    "    \n",
    "    grid_search = GridSearchCV(gbc, param_grid, scoring=\"neg_log_loss\", n_jobs=-1, cv=kfold, verbose=1)\n",
    "    grid_result = grid_search.fit(X, y)\n",
    "    \n",
    "    # Results\n",
    "    print('best Score: {0}'.format(grid_result.best_score_))\n",
    "    print('optimal parameters: {}'.format(grid_result.best_params_))\n",
    "    \n",
    "    means = grid_result.cv_results_['mean_test_score']\n",
    "    stds = grid_result.cv_results_['std_test_score']\n",
    "    params = grid_result.cv_results_['params']\n",
    "    \n",
    "    for mean, stdev, param in zip(means, stds, params):\n",
    "        print(\"mean: {}    std:{}    parameters: {}\".format(mean, stdev, param))\n",
    "    \n",
    "    #Plot\n",
    "    scores = numpy.array(means).reshape(len(max_depth), len(n_estimators))\n",
    "    for i, value in enumerate(max_depth):\n",
    "        plt.plot(n_estimators, scores[i], label='depth: ' + str(value))\n",
    "    plt.legend()\n",
    "    plt.xlabel('n_estimators')\n",
    "    plt.ylabel('Log Loss')\n",
    "    #plt.savefig('n_estimators_vs_max_depth.png')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:classification]",
   "language": "python",
   "name": "conda-env-classification-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
